#!/usr/bin/env python
"""
02_model_training.py

Loads the synthetic blends dataset (blends_dataset.csv), and demonstrates:
  1) A Pipeline for classification (LogisticRegression) with PCA and class_weight="balanced".
  2) A Pipeline for regression (Ridge) with PCA, on in-spec blends only to predict cost.
  3) A Multi-output regression pipeline (Ridge) with PCA, on in-spec blends only
     to predict [Cost_per_bbl, OctaneMargin, RVPExcess] simultaneously.

After training the single-output cost regressor, we generate a scatter plot
(Actual vs. Predicted Cost) and save it as a PNG file.
"""

import pandas as pd
import numpy as np

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression, Ridge
from sklearn.metrics import (accuracy_score, classification_report,
                             mean_squared_error, r2_score)
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.multioutput import RegressorChain

import joblib
import matplotlib.pyplot as plt

# ------------------------------------------------------------------------
# 1) CONFIG
# ------------------------------------------------------------------------
BLENDS_CSV = "data/blends_dataset.csv"   # The synthetic dataset generated by the revised generate_synthetic_blends.py

# Output model filenames
CLASSIFIER_MODEL_FILE        = "models/model_inSpec_classifier.joblib"
REGRESSOR_MODEL_FILE         = "models/model_cost_regressor.joblib"       # Single-output cost
COST_MARGIN_REGRESSOR_FILE   = "models/model_costmargin_regressor.joblib" # Multi-output cost + margin

TEST_SIZE   = 0.2   # 20% test split
RANDOM_SEED = 42

# PCA config
N_COMPONENTS_CLASSIFICATION = 5  # Number of principal components for classification
N_COMPONENTS_REGRESSION     = 5  # Number of principal components for regression

# ------------------------------------------------------------------------
# 2) HELPER FUNCTION: Plot Predicted vs. Actual Cost
# ------------------------------------------------------------------------
def plot_predicted_vs_actual_cost(actual_cost, predicted_cost, save_path="predicted_vs_actual_cost.png"):
    """
    Creates and saves a scatter plot comparing the actual vs. predicted cost per barrel.

    Parameters:
    -----------
    actual_cost : array-like
        The ground truth costs from the test set.
    predicted_cost : array-like
        The predicted costs from the regression model.
    save_path : str
        The file path to save the plot as a PNG image.
    """
    actual_cost = np.array(actual_cost)
    predicted_cost = np.array(predicted_cost)

    plt.figure(figsize=(6, 5))
    plt.scatter(actual_cost, predicted_cost, alpha=0.6, edgecolors='none', label="Data Points")

    # Plot the ideal diagonal where predicted == actual
    min_val = min(actual_cost.min(), predicted_cost.min())
    max_val = max(actual_cost.max(), predicted_cost.max())
    plt.plot([min_val, max_val], [min_val, max_val], 'r--', label='Perfect Prediction')

    plt.xlabel("Actual Cost per bbl (US$)")
    plt.ylabel("Predicted Cost per bbl (US$)")
    plt.title("Predicted vs. Actual Cost for Single-Output Regression")
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.tight_layout()

    # Save figure as PNG 
    plt.savefig(save_path, dpi=300)
    plt.close()

# ------------------------------------------------------------------------
# 3) MAIN FUNCTION
# ------------------------------------------------------------------------
def main():
    # 3.1) LOAD DATA
    df = pd.read_csv(BLENDS_CSV)

    print("Loaded dataset shape:", df.shape)
    print("Columns:", df.columns.tolist())
    print("Sample rows:\n", df.head())

    # --------------------------------------------------------------------
    # 3.2) CLASSIFICATION: Predict InSpec with PCA + Logistic Regression
    # --------------------------------------------------------------------
    df["GasolineTypeEncoded"] = df["GasolineType"].map({"regular": 0, "premium": 1})
    df["SeasonEncoded"] = df["Season"].map({"winter": 0, "summer": 1})

    classification_features = [
        "ReformateVol", "LHCN/HHCVol", "LCNVol", "CYHEX/SATC6Vol",
        "AlkylateVol", "CC5/DimateVol", "SATC5Vol", "NC4Vol",
        "GasolineTypeEncoded", "SeasonEncoded"
    ]
    X_cls = df[classification_features].copy()
    y_cls = df["InSpec"]  # 0 or 1

    X_train_cls, X_test_cls, y_train_cls, y_test_cls = train_test_split(
        X_cls, y_cls, test_size=TEST_SIZE, random_state=RANDOM_SEED
    )

    classifier_pipeline = Pipeline([
        ("scaler", StandardScaler()),
        ("pca", PCA(n_components=N_COMPONENTS_CLASSIFICATION, random_state=RANDOM_SEED)),
        ("logreg", LogisticRegression(
            random_state=RANDOM_SEED,
            max_iter=1000,
            class_weight="balanced"
        ))
    ])

    classifier_pipeline.fit(X_train_cls, y_train_cls)

    y_pred_cls = classifier_pipeline.predict(X_test_cls)
    acc = accuracy_score(y_test_cls, y_pred_cls)
    print("\n--- Classification with PCA + LogisticRegression (balanced) ---")
    print(f"Accuracy: {acc:.3f}")
    print("Classification Report:\n", classification_report(y_test_cls, y_pred_cls))

    pca_step_cls = classifier_pipeline.named_steps["pca"]
    print("PCA (classification) - Explained Variance Ratios:", pca_step_cls.explained_variance_ratio_)
    print("PCA (classification) - Total Variance Captured: ", pca_step_cls.explained_variance_ratio_.sum())

    joblib.dump(classifier_pipeline, CLASSIFIER_MODEL_FILE)
    print(f"Saved InSpec classifier pipeline to {CLASSIFIER_MODEL_FILE}")

    # --------------------------------------------------------------------
    # 3.3) REGRESSION: Predict Cost_per_bbl (single-output) on In-spec only
    # --------------------------------------------------------------------
    df_in_spec = df[df["InSpec"] == 1].copy()
    if len(df_in_spec) == 0:
        print("Warning: No in-spec blends found! Cannot train cost regression.")
        return

    df_in_spec["GasolineTypeEncoded"] = df_in_spec["GasolineType"].map({"regular": 0, "premium": 1})
    df_in_spec["SeasonEncoded"]       = df_in_spec["Season"].map({"winter": 0, "summer": 1})

    regression_features = [
        "ReformateVol", "LHCN/HHCVol", "LCNVol", "CYHEX/SATC6Vol",
        "AlkylateVol", "CC5/DimateVol", "SATC5Vol", "NC4Vol",
        "GasolineTypeEncoded", "SeasonEncoded"
    ]
    X_reg = df_in_spec[regression_features]
    y_reg = df_in_spec["Cost_per_bbl"]

    X_train_reg, X_test_reg, y_train_reg, y_test_reg = train_test_split(
        X_reg, y_reg, test_size=TEST_SIZE, random_state=RANDOM_SEED
    )

    regressor_pipeline = Pipeline([
        ("scaler", StandardScaler()),
        ("pca", PCA(n_components=N_COMPONENTS_REGRESSION, random_state=RANDOM_SEED)),
        ("ridge", Ridge(alpha=1.0, random_state=RANDOM_SEED))
    ])

    regressor_pipeline.fit(X_train_reg, y_train_reg)

    y_pred_reg = regressor_pipeline.predict(X_test_reg)
    mse = mean_squared_error(y_test_reg, y_pred_reg)
    r2  = r2_score(y_test_reg, y_pred_reg)

    print("\n--- Single-Output Regression (Cost) with PCA + Ridge (In-spec only) ---")
    print(f"MSE: {mse:.3f}")
    print(f"R^2: {r2:.3f}")

    pca_step_reg = regressor_pipeline.named_steps["pca"]
    print("PCA (regression) - Explained Variance Ratios:", pca_step_reg.explained_variance_ratio_)
    print("PCA (regression) - Total Variance Captured: ", pca_step_reg.explained_variance_ratio_.sum())

    joblib.dump(regressor_pipeline, REGRESSOR_MODEL_FILE)
    print(f"Saved single-output cost regressor pipeline to {REGRESSOR_MODEL_FILE}")

    # --------------------------------------------------------------------
    # 3.4) PLOT PREDICTED vs ACTUAL COST & SAVE PNG
    # --------------------------------------------------------------------
    print("\nGenerating scatter plot for Predicted vs. Actual Cost...")
    plot_predicted_vs_actual_cost(y_test_reg, y_pred_reg, save_path="predicted_vs_actual_cost.png")
    print("Plot saved as 'predicted_vs_actual_cost.png'")

    # --------------------------------------------------------------------
    # 3.5) MULTI-OUTPUT REGRESSION: Cost, OctaneMargin, RVPExcess
    # --------------------------------------------------------------------
    if not all(col in df_in_spec.columns for col in ["OctaneMargin", "RVPExcess"]):
        print("Warning: Margin columns not found! Skipping multi-output regression.")
        return

    X_mo = df_in_spec[regression_features]
    y_mo = df_in_spec[["Cost_per_bbl", "OctaneMargin", "RVPExcess"]].copy()

    X_train_mo, X_test_mo, y_train_mo, y_test_mo = train_test_split(
        X_mo, y_mo, test_size=TEST_SIZE, random_state=RANDOM_SEED
    )

    multi_reg_pipeline = Pipeline([
        ("scaler", StandardScaler()),
        ("pca", PCA(n_components=N_COMPONENTS_REGRESSION, random_state=RANDOM_SEED)),
        ("ridge", Ridge(alpha=1.0, random_state=RANDOM_SEED))
    ])

    multi_reg_pipeline.fit(X_train_mo, y_train_mo)
    y_pred_mo = multi_reg_pipeline.predict(X_test_mo)

    cost_mse   = mean_squared_error(y_test_mo.iloc[:,0], y_pred_mo[:,0])
    cost_r2    = r2_score(y_test_mo.iloc[:,0], y_pred_mo[:,0])

    oct_mse    = mean_squared_error(y_test_mo.iloc[:,1], y_pred_mo[:,1])
    oct_r2     = r2_score(y_test_mo.iloc[:,1], y_pred_mo[:,1])

    rvp_mse    = mean_squared_error(y_test_mo.iloc[:,2], y_pred_mo[:,2])
    rvp_r2     = r2_score(y_test_mo.iloc[:,2], y_pred_mo[:,2])

    print("\n--- Multi-Output Regression (Cost, OctaneMargin, RVPExcess) ---")
    print(f" Cost MSE={cost_mse:.3f},  R^2={cost_r2:.3f}")
    print(f" OctaneMargin MSE={oct_mse:.3f},  R^2={oct_r2:.3f}")
    print(f" RVPExcess   MSE={rvp_mse:.3f},   R^2={rvp_r2:.3f}")

    pca_step_mo = multi_reg_pipeline.named_steps["pca"]
    print("PCA (multi-output) - Explained Variance Ratios:", pca_step_mo.explained_variance_ratio_)
    print("PCA (multi-output) - Total Variance Captured: ", pca_step_mo.explained_variance_ratio_.sum())

    joblib.dump(multi_reg_pipeline, COST_MARGIN_REGRESSOR_FILE)
    print(f"Saved multi-output regressor pipeline to {COST_MARGIN_REGRESSOR_FILE}")

if __name__ == "__main__":
    main()
